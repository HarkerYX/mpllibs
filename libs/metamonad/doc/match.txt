//    Copyright Abel Sinkovics (abel@sinkovics.hu) 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

match
=====
Abel Sinkovics

Synopsis
--------

--------------------------------------
template <class Pattern, class Expression>
struct match
{
  // unspecified
};
--------------------------------------


Description
-----------

Metafunction implementing pattern matching. It matches the angly-bracket
expression +Expression+ against the pattern +Pattern+.

Every class matches itself. The following two cases are exceptions:

* +Pattern+ may contain instances of the +template <class Name> struct var;+
  template. These instances refer to open variables of the pattern. Any class
  matches them. When multiple occurrences of the same variable would match
  different classes, the expression doesn't match the pattern.

* +Pattern+ may contain the +_+ class, which refer to an anonymous open
  variable. Any class matches it.

When the expression matches the pattern, +match+ returns a +boost::mpl::map+,
where they keys are the open variables of the pattern and the values are the
classes that were matched against them.

When the expression doesn't match, +match+ returns an
link:exception.html[+exception+].

Header
------

--------------------------------------
#include <mpllibs/metamonad/match.hpp>
--------------------------------------

Expression semantics
--------------------

For any +x+ and +y+ classes, +t1+ and +t2+ templates taking two classes as
arguments the following are equivalent:

--------------------------------------
using namespace boost::mpl;

match<int, int>::type
map<>

match<_, int>::type
map<>

match<int, double>::type
exception<...>

match<var<x>, int>::type
map<pair<x, int>>

match<t1<var<x>, var<y>>, t1<int, double>>::type
map<pair<x, int>, pair<y, double>>

match<t1<var<x>, var<y>>, t2<int, double>>::type
exception<...>

match<t1<var<x>, var<x>>, t1<int, int>>::type
map<pair<x, int>>

match<t1<var<x>, var<x>>, t1<int, double>>::type
exception<...>

match<var<x>, t1<int, double>>::type
map<pair<x, t1<int, double>>>
--------------------------------------

Example
-------

--------------------------------------
template <class A>
struct maybe_something :
  boost::mpl::if_<
    typename boost::is_same<A, int>::type,
    just<double>,
    nothing
  >
{};

struct x;

typedef
  boost::mpl::at<
    match<just<var<x>>, maybe_something<int>::type>::type,
    x
  >::type
  this_is_double;
--------------------------------------

include::copyright[]

link:reference.html[[up]]



